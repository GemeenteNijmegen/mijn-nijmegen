import * as path from 'path';
import { aws_lambda as Lambda, aws_dynamodb, aws_ssm as SSM } from 'aws-cdk-lib';
import { FilterPattern, IFilterPattern, RetentionDays, SubscriptionFilter } from 'aws-cdk-lib/aws-logs';
import { LambdaDestination } from 'aws-cdk-lib/aws-logs-destinations';
import { Construct } from 'constructs';
import { Statics } from './statics';

export interface ApiFunctionProps {
  description: string;
  codePath: string;
  table: aws_dynamodb.ITable;
  tablePermissions: string;
  applicationUrlBase?: string;
  environment?: {[key: string]: string};
  monitoredBy?: Lambda.IFunction;
  monitorFilterPattern?: IFilterPattern;
}

export class ApiFunction extends Construct {
  lambda: Lambda.Function;
  constructor(scope: Construct, id: string, props: ApiFunctionProps) {
    super(scope, id);
    // See https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-extension-versionsx86-64.html
    const insightsArn = 'arn:aws:lambda:eu-west-1:580247275435:layer:LambdaInsightsExtension:16';
    this.lambda = new Lambda.Function(this, 'lambda', {
      runtime: Lambda.Runtime.NODEJS_14_X,
      handler: 'index.handler',
      description: props.description,
      code: Lambda.Code.fromAsset(path.join(__dirname, props.codePath)),
      insightsVersion: Lambda.LambdaInsightsVersion.fromInsightVersionArn(insightsArn),
      logRetention: RetentionDays.ONE_MONTH,
      environment: {
        APPLICATION_URL_BASE: props.applicationUrlBase || '',
        AUTH_URL_BASE: SSM.StringParameter.valueForStringParameter(this, Statics.ssmAuthUrlBaseParameter),
        OIDC_CLIENT_ID: SSM.StringParameter.valueForStringParameter(this, Statics.ssmOIDCClientID),
        OIDC_SCOPE: SSM.StringParameter.valueForStringParameter(this, Statics.ssmOIDCScope),
        SESSION_TABLE: props.table.tableName,
        ...props.environment,
      },
    });
    props.table.grantReadWriteData(this.lambda.grantPrincipal);

    if (props.monitoredBy) {
      this.monitor(props.monitoredBy, props.monitorFilterPattern);
    }
  }

  /**
   * Monitor the logs generated by this function for a filter pattern, send
   * to specified lambda.
   *
   * @param monitoredBy Lambda function responsible for monitoring this function
   * @param filterPattern Pattern to filter by (default: containing ERROR)
   */
  private monitor(monitoredBy: Lambda.IFunction, filterPattern?: IFilterPattern) {
    new SubscriptionFilter(this, 'error-logs-subscription', {
      logGroup: this.lambda.logGroup,
      destination: new LambdaDestination(monitoredBy),
      filterPattern: filterPattern ?? FilterPattern.anyTerm('ERROR'),
    });
  }
}
